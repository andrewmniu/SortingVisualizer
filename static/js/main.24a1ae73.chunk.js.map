{"version":3,"sources":["components/Controls.js","algorithms/bubbleSort.js","algorithms/insertionSort.js","algorithms/selectionSort.js","algorithms/mergeSort.js","algorithms/heapSort.js","algorithms/quickSort.js","components/SortingVisualizer.js","App.js","serviceWorker.js","index.js"],"names":["Controls","id","className","disabled","this","props","sorting","onClick","resetArray","bind","array","length","sort","value","algorithm","onChange","choose","htmlFor","type","name","min","max","step","e","target","React","Component","bubbleSort","arr","speed","bars","colors","animations","i","j","push","swap","temp","bubbleSortAnimation","sorted","frame","first","second","setTimeout","style","backgroundColor","compare","tempHeight","height","unsorted","Math","round","insertionSort","next","insertionSortAnimation","selectionSort","min_idx","selectionSortAnimation","slice","console","log","mergeSort","mergeSortAnimation","l","r","m","floor","L","R","k","merge","heapSort","heapify","heapSortAnimation","n","largest","quickSort","quickSortAnimation","low","high","p","pivot","partition","randomInt","random","SortingVisualizer","state","inverse","barStyle","idx","position","width","borderRight","left","bottom","float","marginBottom","size","document","getElementsByClassName","setState","runAlgorithm","undefined","finishTime","sortedArray","log2","Fragment","map","key","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"kPAmEeA,E,uKA9DH,IAAD,OACP,OACE,4BAAQC,GAAG,cACT,4BACEC,UAAU,UACVC,SAAUC,KAAKC,MAAMC,QACrBC,QAASH,KAAKC,MAAMG,WAAWC,KAAKL,KAAMA,KAAKC,MAAMK,MAAMC,SAH7D,aAOA,4BACET,UAAU,UACVC,SAAUC,KAAKC,MAAMC,QACrBC,QAASH,KAAKC,MAAMO,MAHtB,QAOA,4BACEC,MAAOT,KAAKC,MAAMS,UAClBb,GAAG,aACHC,UAAU,UACVC,SAAUC,KAAKC,MAAMC,QACrBS,SAAUX,KAAKC,MAAMW,QAErB,4BAAQH,MAAM,UAAd,eACA,4BAAQA,MAAM,aAAd,kBACA,4BAAQA,MAAM,aAAd,kBACA,4BAAQA,MAAM,SAAd,cACA,4BAAQA,MAAM,QAAd,aACA,4BAAQA,MAAM,SAAd,eAEF,yBAAKZ,GAAG,iBAAiBC,UAAU,WACjC,2BAAOe,QAAQ,QAAf,SACA,2BACEC,KAAK,QACLjB,GAAG,OACHC,UAAU,SACViB,KAAK,OACLC,IAAI,IACJC,IAAI,MACJC,KAAK,IACLT,MAAOT,KAAKC,MAAMK,MAAMC,OACxBR,SAAUC,KAAKC,MAAMC,QACrBS,SAAU,SAACQ,GACT,EAAKlB,MAAMG,WAAWe,EAAEC,OAAOX,gB,GA9CtBY,IAAMC,WCHtB,SAASC,EAAWC,EAAKC,EAAOC,EAAMC,GAG3C,IAHoD,IAAD,EAkCrD,SAA6BH,GAE3B,IADA,IAAMI,EAAa,GACVC,EAAI,EAAGA,EAAIL,EAAIjB,OAAQsB,IAC9B,IAAK,IAAIC,EAAI,EAAGA,EAAIN,EAAIjB,OAAS,EAAIsB,EAAGC,IAAK,CAC3CF,EAAWG,KAAK,CAACD,EAAGA,EAAI,IACxB,IAAIE,EAAOR,EAAIM,GAAKN,EAAIM,EAAI,GAE5B,GADAF,EAAWG,KAAKC,GACZA,EAAM,CACR,IAAMC,EAAOT,EAAIM,GACjBN,EAAIM,GAAKN,EAAIM,EAAI,GACjBN,EAAIM,EAAI,GAAKG,GAInB,MAAO,CAACL,EAAYJ,GA/CSU,CAAoBV,GADE,mBAC5CI,EAD4C,KAChCO,EADgC,KAE/CC,EAAQ,EAFuC,gCAIzBR,EAAWC,GAJc,GAI1CQ,EAJ0C,KAInCC,EAJmC,KAMjDC,YAAW,WACTb,EAAKW,GAAOG,MAAMC,gBAAkBd,EAAOe,QAC3ChB,EAAKY,GAAQE,MAAMC,gBAAkBd,EAAOe,UAC3CjB,EAAQW,GACXA,IACAP,IAEAU,YAAW,WACT,GAAIX,EAAWC,GAAI,CACjBH,EAAKW,GAAOG,MAAMC,gBAAkBd,EAAOK,KAC3CN,EAAKY,GAAQE,MAAMC,gBAAkBd,EAAOK,KAC5C,IAAMW,EAAajB,EAAKW,GAAOG,MAAMI,OACrClB,EAAKW,GAAOG,MAAMI,OAASlB,EAAKY,GAAQE,MAAMI,OAC9ClB,EAAKY,GAAQE,MAAMI,OAASD,KAE7BlB,EAAQW,GACXA,IAEAG,YAAW,WACTb,EAAKW,GAAOG,MAAMC,gBAAkBd,EAAOkB,SAC3CnB,EAAKY,GAAQE,MAAMC,gBAAkBd,EAAOkB,WAC3CpB,EAAQW,GACXA,IA5BiD,KAG1CP,EAAI,EAAGA,EAAID,EAAWrB,OAAQsB,IAAM,EAApCA,GA2BT,MAAO,CAACiB,KAAKC,MAAMtB,EAAQW,GAAQD,GC9B9B,SAASa,EAAcxB,EAAKC,EAAOC,EAAMC,GAG9C,IAHuD,IAAD,EA2CxD,SAAgCH,GAE9B,IADA,IAAMI,EAAa,GACVC,EAAI,EAAGA,EAAIL,EAAIjB,OAAQsB,IAAK,CACnC,IAAMoB,EAAOzB,EAAIK,GACbC,EAAID,EAAI,EAEZ,IADAD,EAAWG,KAAK,CAACF,IACVC,GAAK,GAAKmB,EAAOzB,EAAIM,IAC1BN,EAAIM,EAAI,GAAKN,EAAIM,GACjBF,EAAWG,KAAK,CAACD,EAAGA,EAAI,IACxBA,IAEFN,EAAIM,EAAI,GAAKmB,EAEf,MAAO,CAACrB,EAAYJ,GAvDS0B,CAAuB1B,GADE,mBAC/CI,EAD+C,KACnCO,EADmC,KAElDC,EAAQ,EAF0C,WAG7CP,GAEP,GAA6B,IAAzBD,EAAWC,GAAGtB,OAChBgC,YAAW,WACTb,EAAKE,EAAWC,IAAIW,MAAMC,gBAAkBd,EAAOe,UAClDjB,EAAQW,IAEPP,EAAI,GAAKD,EAAWrB,QAAuC,IAA7BqB,EAAWC,EAAI,GAAGtB,UAClD6B,IACAG,YAAW,WACTb,EAAKE,EAAWC,IAAIW,MAAMC,gBAAkBd,EAAOkB,WAClDpB,EAAQW,QAER,CAAC,IAAD,cACmBR,EAAWC,GAD9B,GACEQ,EADF,KACSC,EADT,KAGLC,YAAW,WACTb,EAAKW,GAAOG,MAAMC,gBAAkBd,EAAOK,KAC3CN,EAAKY,GAAQE,MAAMC,gBAAkBd,EAAOK,OAC3CP,EAAQW,GACXA,IAEAG,YAAW,WACT,IAAMI,EAAajB,EAAKW,GAAOG,MAAMI,OACrClB,EAAKW,GAAOG,MAAMI,OAASlB,EAAKY,GAAQE,MAAMI,OAC9ClB,EAAKY,GAAQE,MAAMI,OAASD,IAC3BlB,EAAQW,GACXA,IAEAG,YAAW,WACTb,EAAKW,GAAOG,MAAMC,gBAAkBd,EAAOkB,SAC3CnB,EAAKY,GAAQE,MAAMC,gBAAkBd,EAAOkB,WAC3CpB,EAAQW,GAEbA,KAlCOP,EAAI,EAAGA,EAAID,EAAWrB,OAAQsB,IAAM,EAApCA,GAoCT,MAAO,CAACiB,KAAKC,MAAMtB,EAAQW,GAAQD,GCvC9B,SAASgB,EAAc3B,EAAKC,EAAOC,EAAMC,GAG9C,IAHuD,IAAD,EAkDxD,SAAgCH,GAE9B,IADA,IAAMI,EAAa,GACVC,EAAI,EAAGA,EAAIL,EAAIjB,OAAS,EAAGsB,IAAK,CACvCD,EAAWG,KAAK,CAAC,OAAQF,IAEzB,IADA,IAAIuB,EAAUvB,EACLC,EAAID,EAAI,EAAGC,EAAIN,EAAIjB,OAAQuB,IAClCF,EAAWG,KAAK,CAAC,SAAUD,IACvBN,EAAIM,GAAKN,EAAI4B,KACfA,EAAUtB,GAIdF,EAAWG,KAAK,CAAC,OAAQF,EAAGuB,IAC5B,IAAMnB,EAAOT,EAAI4B,GACjB5B,EAAI4B,GAAW5B,EAAIK,GACnBL,EAAIK,GAAKI,EAEX,MAAO,CAACL,EAAYJ,GAlES6B,CAAuB7B,GADE,mBAC/CI,EAD+C,KACnCO,EADmC,KAElDC,EAAQ,EAF0C,WAG7CP,GACP,OAAQD,EAAWC,GAAG,IACpB,IAAK,OAEHU,YAAW,WACTb,EAAKE,EAAWC,GAAG,IAAIW,MAAMC,gBAAkBd,EAAOe,UACrDjB,EAAQW,GACX,MACF,IAAK,SAEHG,YAAW,WACTb,EAAKE,EAAWC,GAAG,IAAIW,MAAMC,gBAAkBd,EAAOe,UACrDjB,EAAQW,GACXA,IACAG,YAAW,WACTb,EAAKE,EAAWC,GAAG,IAAIW,MAAMC,gBAAkBd,EAAOkB,WACrDpB,EAAQW,GACX,MACF,IAAK,OAAL,MAE0BR,EAAWC,GAAGyB,MAAM,GAF9C,mBAESjB,EAFT,KAEgBC,EAFhB,KAGEC,YAAW,WACTb,EAAKW,GAAOG,MAAMC,gBAAkBd,EAAOK,KAC3CN,EAAKY,GAAQE,MAAMC,gBAAkBd,EAAOK,OAC3CP,EAAQW,GACXA,IACAG,YAAW,WACT,IAAMI,EAAajB,EAAKW,GAAOG,MAAMI,OACrClB,EAAKW,GAAOG,MAAMI,OAASlB,EAAKY,GAAQE,MAAMI,OAC9ClB,EAAKY,GAAQE,MAAMI,OAASD,IAC3BlB,EAAQW,GACXA,IACAG,YAAW,WACTb,EAAKW,GAAOG,MAAMC,gBAAkBd,EAAOkB,SAC3CnB,EAAKY,GAAQE,MAAMC,gBAAkBd,EAAOkB,WAC3CpB,EAAQW,GACX,MACF,QACEmB,QAAQC,IAAI,SAGhBpB,KAzCOP,EAAI,EAAGA,EAAID,EAAWrB,OAAQsB,IAAM,EAApCA,GA2CT,MAAO,CAACiB,KAAKC,MAAMtB,EAAQW,GAAQD,GC9C9B,SAASsB,EAAUjC,EAAKC,EAAOC,EAAMC,GAI1C,IAHA,IAAMC,EAAa,GACbO,EA+CR,SAASuB,EAAmBlC,EAAKmC,EAAGC,EAAGhC,GACrC,GAAI+B,EAAIC,EAAG,CACT,IAAMC,EAAIf,KAAKgB,OAAOH,EAAIC,GAAK,GAE/BF,EAAmBlC,EAAKmC,EAAGE,EAAGjC,GAC9B8B,EAAmBlC,EAAKqC,EAAI,EAAGD,EAAGhC,GAQtC,SAAeJ,EAAKmC,EAAGE,EAAGD,EAAGhC,GAC3B,IAAMmC,EAAIvC,EAAI8B,MAAMK,EAAGE,EAAI,GACrBG,EAAIxC,EAAI8B,MAAMO,EAAI,EAAGD,EAAI,GAE3B/B,EAAI,EACJC,EAAI,EACJmC,EAAIN,EAER,KAAO9B,EAAIkC,EAAExD,QAAUuB,EAAIkC,EAAEzD,QAC3BqB,EAAWG,KAAK,CAAC,OAAQ4B,EAAI9B,EAAGgC,EAAI,EAAI/B,IACpCiC,EAAElC,GAAKmC,EAAElC,IACXN,EAAIyC,GAAKF,EAAElC,GAIP8B,EAAI9B,GAAKoC,GACXrC,EAAWG,KAAK,CAAC,OAAQkC,EAAGN,EAAI9B,IAElCA,MAEAL,EAAIyC,GAAKD,EAAElC,GACP+B,EAAI,EAAI/B,GAAKmC,GACfrC,EAAWG,KAAK,CAAC,OAAQkC,EAAGJ,EAAI,EAAI/B,IAEtCA,KAEFmC,IAIF,KAAOpC,EAAIkC,EAAExD,QACXiB,EAAIyC,GAAKF,EAAElC,GACXA,IACAoC,IAEF,KAAOnC,EAAIkC,EAAEzD,QACXiB,EAAIyC,GAAKD,EAAElC,GACXA,IACAmC,IA5CAC,CAAM1C,EAAKmC,EAAGE,EAAGD,EAAGhC,GAEtB,OAAOJ,EAxDQkC,CAAmBlC,EAAK,EAAGA,EAAIjB,OAAS,EAAGqB,GACtDQ,EAAQ,EAHsC,WAIzCP,GAJyC,MAKxBD,EAAWC,GAAGyB,MAAM,GALI,mBAKzCjB,EALyC,KAKlCC,EALkC,KAMhD,OAAQV,EAAWC,GAAG,IAEpB,IAAK,OACHU,YAAW,WACTb,EAAKW,GAAOG,MAAMC,gBAAkBd,EAAOe,QAC3ChB,EAAKY,GAAQE,MAAMC,gBAAkBd,EAAOe,UAC3CjB,EAAQW,GACXA,IACA,MACF,IAAK,OAECC,IAAUC,IACZC,YAAW,WACTb,EAAKW,GAAOG,MAAMC,gBAAkBd,EAAOK,KAC3CN,EAAKY,GAAQE,MAAMC,gBAAkBd,EAAOK,OAC3CP,EAAQW,GACXA,IACAG,YAAW,WACT,IAAMI,EAAajB,EAAKW,GAAOG,MAAMI,OACrClB,EAAKW,GAAOG,MAAMI,OAASlB,EAAKY,GAAQE,MAAMI,OAE9C,IAAK,IAAId,EAAIQ,EAAQR,EAAIO,EAAQ,EAAGP,IAClCJ,EAAKI,GAAGU,MAAMI,OAASlB,EAAKI,EAAI,GAAGU,MAAMI,OAE3ClB,EAAKW,EAAQ,GAAGG,MAAMI,OAASD,IAC9BlB,EAAQW,IAEb,MACF,QACEmB,QAAQC,IAAI,SAGhBjB,YAAW,WACTb,EAAKW,GAAOG,MAAMC,gBAAkBd,EAAOkB,SAC3CnB,EAAKY,GAAQE,MAAMC,gBAAkBd,EAAOkB,WAC3CpB,EAAQW,GACXA,KAtCOP,EAAI,EAAGA,EAAID,EAAWrB,OAAQsB,IAAM,EAApCA,GAwCT,MAAO,CAACiB,KAAKC,MAAMtB,EAAQW,GAAQD,GC5C9B,SAASgC,EAAS3C,EAAKC,EAAOC,EAAMC,GAIzC,IAHA,IAAMC,EAAa,GACbO,EAsDR,SAA2BX,EAAKI,GAC9B,IAAK,IAAIC,EAAIiB,KAAKgB,MAAMtC,EAAIjB,OAAS,GAAK,EAAGsB,GAAK,EAAGA,IACnDuC,EAAQ5C,EAAKA,EAAIjB,OAAQsB,EAAGD,GAG9B,IAAK,IAAIC,EAAIL,EAAIjB,OAAS,EAAGsB,EAAI,EAAGA,IAAK,CACvCD,EAAWG,KAAK,CAAC,MAAO,EAAGF,IAC3B,IAAMI,EAAOT,EAAI,GACjBA,EAAI,GAAKA,EAAIK,GACbL,EAAIK,GAAKI,EACTmC,EAAQ5C,EAAKK,EAAG,EAAGD,GAErB,OAAOJ,EAlEQ6C,CAAkB7C,EAAKI,GAClCQ,EAAQ,EAHqC,WAIxCP,GAJwC,MAKvBD,EAAWC,GAAGyB,MAAM,GALG,mBAKxCjB,EALwC,KAKjCC,EALiC,KAM/C,OAAQV,EAAWC,GAAG,IAEpB,IAAK,UACHU,YAAW,WACTb,EAAKW,GAAOG,MAAMC,gBAAkBd,EAAOe,QAC3ChB,EAAKY,GAAQE,MAAMC,gBAAkBd,EAAOe,UAC3CjB,EAAQW,GACXA,IACA,MAEF,IAAK,OACHG,YAAW,WACTb,EAAKW,GAAOG,MAAMC,gBAAkBd,EAAOK,KAC3CN,EAAKY,GAAQE,MAAMC,gBAAkBd,EAAOK,OAC3CP,EAAQW,GACXA,IACAG,YAAW,WACT,IAAMI,EAAajB,EAAKW,GAAOG,MAAMI,OACrClB,EAAKW,GAAOG,MAAMI,OAASlB,EAAKY,GAAQE,MAAMI,OAC9ClB,EAAKY,GAAQE,MAAMI,OAASD,IAC3BlB,EAAQW,GACX,MAEF,IAAK,MACHG,YAAW,WACTb,EAAKW,GAAOG,MAAMC,gBAAkBd,EAAOK,KAC3CN,EAAKY,GAAQE,MAAMC,gBAAkBd,EAAOK,OAC3CP,EAAQW,GACXA,IACAG,YAAW,WACT,IAAMI,EAAajB,EAAKW,GAAOG,MAAMI,OACrClB,EAAKW,GAAOG,MAAMI,OAASlB,EAAKY,GAAQE,MAAMI,OAC9ClB,EAAKY,GAAQE,MAAMI,OAASD,IAC3BlB,EAAQW,GACX,MACF,QACEmB,QAAQC,IAAI,SAGhBjB,YAAW,WACTb,EAAKW,GAAOG,MAAMC,gBAAkBd,EAAOkB,SAC3CnB,EAAKY,GAAQE,MAAMC,gBAAkBd,EAAOkB,WAC3CpB,EAAQW,GACXA,KA7COP,EAAI,EAAGA,EAAID,EAAWrB,OAAQsB,IAAM,EAApCA,GA+CT,MAAO,CAACiB,KAAKC,MAAMtB,EAAQW,GAAQD,GAqBrC,SAASiC,EAAQ5C,EAAK8C,EAAGzC,EAAGD,GAC1B,IAAI2C,EAAU1C,EACR8B,EAAI,EAAI9B,EAAI,EACZ+B,EAAI,EAAI/B,EAAI,EAclB,GAbI8B,EAAIW,IACN1C,EAAWG,KAAK,CAAC,UAAWwC,EAASZ,IACjCnC,EAAImC,GAAKnC,EAAI+C,KACfA,EAAUZ,IAGVC,EAAIU,IACN1C,EAAWG,KAAK,CAAC,UAAWwC,EAASX,IACjCpC,EAAIoC,GAAKpC,EAAI+C,KACfA,EAAUX,IAIVW,IAAY1C,EAAG,CACjBD,EAAWG,KAAK,CAAC,OAAQF,EAAG0C,IAC5B,IAAMtC,EAAOT,EAAIK,GACjBL,EAAIK,GAAKL,EAAI+C,GACb/C,EAAI+C,GAAWtC,EAEfmC,EAAQ5C,EAAK8C,EAAGC,EAAS3C,IC/FtB,IAAM4C,EAAY,SAAChD,EAAKC,EAAOC,EAAMC,GAI1C,IAHA,IAAMC,EAAa,GACbO,EAkDR,SAASsC,EAAmBjD,EAAKkD,EAAKC,EAAM/C,GAC1C,GAAI8C,EAAMC,EAAM,CACd,IAAIC,EASR,SAAmBpD,EAAKkD,EAAKC,EAAM/C,GACjC,IAAMiD,EAAQrD,EAAImD,GAClB/C,EAAWG,KAAK,CAAC,QAAS4C,IAE1B,IADA,IAAI9C,EAAI6C,EACC5C,EAAI4C,EAAK5C,EAAI6C,EAAM7C,IAE1B,GADAF,EAAWG,KAAK,CAAC,UAAWD,IACxBN,EAAIM,GAAK+C,EAAO,CAClBjD,EAAWG,KAAK,CAAC,OAAQF,EAAGC,IAC5B,IAAMG,EAAOT,EAAIK,GACjBL,EAAIK,GAAKL,EAAIM,GACbN,EAAIM,GAAKG,EACTJ,IAMJ,OAHAD,EAAWG,KAAK,CAAC,OAAQF,EAAG8C,IAC5BnD,EAAImD,GAAQnD,EAAIK,GAChBL,EAAIK,GAAKgD,EACFhD,EA1BGiD,CAAUtD,EAAKkD,EAAKC,EAAM/C,GAElC6C,EAAmBjD,EAAKkD,EAAKE,EAAI,EAAGhD,GACpC6C,EAAmBjD,EAAKoD,EAAI,EAAGD,EAAM/C,GAEvC,OAAOJ,EAzDQiD,CAAmBjD,EAAK,EAAGA,EAAIjB,OAAS,EAAGqB,GACtDQ,EAAQ,EAHyC,WAI5CP,GAJ4C,MAK3BD,EAAWC,GAAGyB,MAAM,GALO,mBAK5CjB,EAL4C,KAKrCC,EALqC,KAMnD,OAAQV,EAAWC,GAAG,IAEpB,IAAK,QACHU,YAAW,WACTb,EAAKW,GAAOG,MAAMC,gBAAkB,SACnChB,EAAQW,GACX,MAEF,IAAK,UACHG,YAAW,WACTb,EAAKW,GAAOG,MAAMC,gBAAkBd,EAAOe,UAC1CjB,EAAQW,GACXA,IACAG,YAAW,WACTb,EAAKW,GAAOG,MAAMC,gBAAkBd,EAAOkB,WAC1CpB,EAAQW,GACX,MAEF,IAAK,OACHG,YAAW,WACTb,EAAKW,GAAOG,MAAMC,gBAAkBd,EAAOK,KAC3CN,EAAKY,GAAQE,MAAMC,gBAAkBd,EAAOK,OAC3CP,EAAQW,GACXA,IACAG,YAAW,WACT,IAAMI,EAAajB,EAAKW,GAAOG,MAAMI,OACrClB,EAAKW,GAAOG,MAAMI,OAASlB,EAAKY,GAAQE,MAAMI,OAC9ClB,EAAKY,GAAQE,MAAMI,OAASD,IAC3BlB,EAAQW,GACXA,IACAG,YAAW,WACTb,EAAKW,GAAOG,MAAMC,gBAAkBd,EAAOkB,SAC3CnB,EAAKY,GAAQE,MAAMC,gBAAkBd,EAAOkB,WAC3CpB,EAAQW,GACX,MACF,QACEmB,QAAQC,IAAI,SAGhBpB,KAzCOP,EAAI,EAAGA,EAAID,EAAWrB,OAAQsB,IAAM,EAApCA,GA2CT,MAAO,CAACiB,KAAKC,MAAMtB,EAAQW,GAAQD,ICrCrC,IAAMR,EAAS,CACbkB,SAAU,UACVH,QAAS,UACTV,KAAM,UACNG,OAAQ,WAgIV,SAAS4C,EAAU/D,EAAKC,GACtB,OAAO6B,KAAKgB,MAAMhB,KAAKkC,UAAY/D,EAAMD,EAAM,GAAKA,GAGvCiE,M,4MAhIbC,MAAQ,CACN5E,MAAO,GACP6E,QAAS,EACTzE,UAAW,OACXyB,QAAQ,EACRjC,SAAS,G,EAGXkF,SAAW,SAAC3E,EAAO4E,GACjB,MAAO,CACLC,SAAU,WACV7C,gBAAiBd,EAAOkB,SACxBD,OAAO,GAAD,OAAKnC,EAAQ,GAAb,KACN8E,MAAM,GAAD,OAAK,EAAKL,MAAMC,QAAhB,KACLK,YAAY,GAAD,OAAK,EAAKN,MAAMC,QAAhB,oBACXM,KAAK,GAAD,OAAKJ,EAAM,EAAKH,MAAMC,QAAtB,KACJO,OAAQ,IACRC,MAAO,OACPC,aAAc,M,EASlBxF,WAAa,SAACyF,GAEZ,IADA,IAAMvF,EAAQ,GACLuB,EAAI,EAAGA,EAAIgE,EAAMhE,IACxBvB,EAAMyB,KAAKgD,EAAU,EAAG,MAE1B,IAAMrD,EAAOoE,SAASC,uBAAuB,OAC7C,GAAI,EAAKb,MAAM/C,OACb,IAAK,IAAIN,EAAI,EAAGA,EAAIH,EAAKnB,OAAQsB,IAC/BH,EAAKG,GAAGW,MAAMC,gBAAkBd,EAAOkB,SAG3C,EAAKmD,SAAS,CAAE1F,QAAO6E,QAAgB,EAAIU,EAAX,IAAkB1D,QAAQ,K,EAK5D3B,KAAO,WACL,EAAKwF,SAAS,CAAE9F,SAAS,IAUzB,IATA,IACMwB,EAAOoE,SAASC,uBAAuB,OAHlC,EAIuB,EAAKE,aAAL,YAC5B,EAAKf,MAAM5E,YAHL4F,EAKVxE,EACAC,GARS,mBAIJwE,EAJI,KAIQC,EAJR,gBAWFvE,GACPU,YAAW,WACTb,EAAKG,EAAIsE,GAAY3D,MAAMC,gBAAkBd,EAAOQ,SACnDgE,EAAc,KAAO,EAAKjB,MAAM5E,MAAMC,QAAWsB,EAAIsE,KAHjDtE,EAAIsE,EAAYtE,EAAIsE,EAAa,EAAKjB,MAAM5E,MAAMC,OAAQsB,IAAM,EAAhEA,GAKTU,YAAW,WACT,EAAKyD,SAAS,CAAE1F,MAAO8F,EAAalG,SAAS,EAAOiC,QAAQ,MAC3DgE,EAAc,KAAO,EAAKjB,MAAM5E,MAAMC,OAAU,EAAK2E,MAAM5E,MAAMC,S,EAKtE0F,aAAe,SAACzE,EAAKC,EAAOC,GAC1B,OAAQ,EAAKwD,MAAMxE,WACjB,IAAK,SAEH,OAAOa,EAAWC,EADlBC,EAAQ,aAAOD,EAAIjB,OAAU,GACCmB,EAAMC,GACtC,IAAK,YAEH,OAAOwB,EAAc3B,EADrBC,EAAQ,cAAOD,EAAIjB,OAAU,GACImB,EAAMC,GACzC,IAAK,YAEH,OAAOqB,EAAcxB,EADrBC,EAAQ,eAAQD,EAAIjB,OAAU,GACGmB,EAAMC,GACzC,IAAK,QAEH,OAAO8B,EAAUjC,EADjBC,EAAQ,KAAQD,EAAIjB,OAASuC,KAAKuD,KAAK7E,EAAIjB,SACdmB,EAAMC,GACrC,IAAK,OAEH,OAAOwC,EAAS3C,EADhBC,EAAQA,EAAQ,KAAQD,EAAIjB,OAASuC,KAAKuD,KAAK7E,EAAIjB,SACvBmB,EAAMC,GACpC,IAAK,QAEH,OADAF,EAAQ,KAAQD,EAAIjB,OAASuC,KAAKuD,KAAK7E,EAAIjB,SACpCiE,EAAUhD,EAAKC,EAAOC,EAAMC,GACrC,QACE4B,QAAQC,IAAI,W,EAKlB5C,OAAS,SAACO,GACJ,EAAK+D,MAAM/C,QACb,EAAK/B,WAAW,EAAK8E,MAAM5E,MAAMC,QAEnC,EAAKyF,SAAS,CAAEtF,UAAWS,EAAEC,OAAOX,S,kEAzEpCT,KAAKI,WAAW,O,+BA4ER,IAAD,OACP,OACE,kBAAC,IAAMkG,SAAP,KACE,kBAAC,EAAD,CACE5F,UAAWV,KAAKkF,MAAMxE,UACtBJ,MAAON,KAAKkF,MAAM5E,MAClBF,WAAYJ,KAAKI,WACjBI,KAAMR,KAAKQ,KACXN,QAASF,KAAKkF,MAAMhF,QACpBU,OAAQZ,KAAKY,SAEf,yBAAKd,UAAU,aACZE,KAAKkF,MAAM5E,MAAMiG,KAAI,SAAC9F,EAAO4E,GAAR,OACpB,yBACEvF,UAAU,MACV0G,IAAKnB,EACL7C,MAAO,EAAK4C,SAAS3E,EAAO4E,c,GApHVhE,IAAMC,WCHvBmF,G,6KARX,OACE,yBAAK3G,UAAU,OACb,kBAAC,EAAD,W,GAJUuB,IAAMC,YCQJoF,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCbNC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAEFnB,SAASoB,eAAe,SD0HpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACLnE,QAAQmE,MAAMA,EAAMC,c","file":"static/js/main.24a1ae73.chunk.js","sourcesContent":["import React from \"react\";\nimport PropTypes from \"prop-types\";\n\nclass Controls extends React.Component {\n  // onClick={() => this.newArray(this.props.array.length)}\n  render() {\n    return (\n      <header id=\"controlbar\">\n        <button\n          className=\"control\"\n          disabled={this.props.sorting}\n          onClick={this.props.resetArray.bind(this, this.props.array.length)}\n        >\n          Randomize\n        </button>\n        <button\n          className=\"control\"\n          disabled={this.props.sorting}\n          onClick={this.props.sort}\n        >\n          Sort\n        </button>\n        <select\n          value={this.props.algorithm}\n          id=\"algorithms\"\n          className=\"control\"\n          disabled={this.props.sorting}\n          onChange={this.props.choose}\n        >\n          <option value=\"bubble\">Bubble Sort</option>\n          <option value=\"selection\">Selection Sort</option>\n          <option value=\"insertion\">Insertion Sort</option>\n          <option value=\"merge\">Merge Sort</option>\n          <option value=\"heap\">Heap Sort</option>\n          <option value=\"quick\">Quick Sort</option>\n        </select>\n        <div id=\"slidecontainer\" className=\"control\">\n          <label htmlFor=\"size\">Size:</label>\n          <input\n            type=\"range\"\n            id=\"size\"\n            className=\"slider\"\n            name=\"size\"\n            min=\"5\"\n            max=\"300\"\n            step=\"1\"\n            value={this.props.array.length}\n            disabled={this.props.sorting}\n            onChange={(e) => {\n              this.props.resetArray(e.target.value);\n            }}\n          />\n        </div>\n      </header>\n    );\n  }\n}\n\nControls.propTypes = {\n  array: PropTypes.array.isRequired,\n  algorithm: PropTypes.string.isRequired,\n  sorting: PropTypes.bool.isRequired,\n  resetArray: PropTypes.func.isRequired,\n  sort: PropTypes.func.isRequired,\n  choose: PropTypes.func.isRequired,\n};\n\nexport default Controls;\n","export function bubbleSort(arr, speed, bars, colors) {\n  const [animations, sorted] = bubbleSortAnimation(arr);\n  let frame = 0; // animation frame\n  for (let i = 0; i < animations.length; i++) {\n    const [first, second] = animations[i];\n    // highlight two bars being compared\n    setTimeout(() => {\n      bars[first].style.backgroundColor = colors.compare;\n      bars[second].style.backgroundColor = colors.compare;\n    }, speed * frame);\n    frame++;\n    i++;\n    // indicate if they need to be swapped and swap them\n    setTimeout(() => {\n      if (animations[i]) {\n        bars[first].style.backgroundColor = colors.swap;\n        bars[second].style.backgroundColor = colors.swap;\n        const tempHeight = bars[first].style.height;\n        bars[first].style.height = bars[second].style.height;\n        bars[second].style.height = tempHeight;\n      }\n    }, speed * frame);\n    frame++;\n    // return back to normal color\n    setTimeout(() => {\n      bars[first].style.backgroundColor = colors.unsorted;\n      bars[second].style.backgroundColor = colors.unsorted;\n    }, speed * frame);\n    frame++;\n  }\n  return [Math.round(speed * frame), sorted]; // end time of sorting animation\n}\n\n// Creates an array of indices that are being compared/swapped during sorting\nfunction bubbleSortAnimation(arr) {\n  const animations = [];\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr.length - 1 - i; j++) {\n      animations.push([j, j + 1]); // two adjacent values being compared\n      let swap = arr[j] > arr[j + 1];\n      animations.push(swap); // whether the two values are out of order\n      if (swap) {\n        const temp = arr[j];\n        arr[j] = arr[j + 1];\n        arr[j + 1] = temp;\n      }\n    }\n  }\n  return [animations, arr];\n}\n","export function insertionSort(arr, speed, bars, colors) {\n  const [animations, sorted] = insertionSortAnimation(arr);\n  let frame = 0; // animation frame\n  for (let i = 0; i < animations.length; i++) {\n    // highlights next bar to be inserted\n    if (animations[i].length === 1) {\n      setTimeout(() => {\n        bars[animations[i]].style.backgroundColor = colors.compare;\n      }, speed * frame);\n      // returns bar to normal color if it is already in the right spot\n      if (i + 1 >= animations.length || animations[i + 1].length === 1) {\n        frame++;\n        setTimeout(() => {\n          bars[animations[i]].style.backgroundColor = colors.unsorted;\n        }, speed * frame);\n      }\n    } else {\n      const [first, second] = animations[i];\n      // highlights comparisons for insert\n      setTimeout(() => {\n        bars[first].style.backgroundColor = colors.swap;\n        bars[second].style.backgroundColor = colors.swap;\n      }, speed * frame);\n      frame++;\n      // switches values\n      setTimeout(() => {\n        const tempHeight = bars[first].style.height;\n        bars[first].style.height = bars[second].style.height;\n        bars[second].style.height = tempHeight;\n      }, speed * frame);\n      frame++;\n      // returns bars to normal colors\n      setTimeout(() => {\n        bars[first].style.backgroundColor = colors.unsorted;\n        bars[second].style.backgroundColor = colors.unsorted;\n      }, speed * frame);\n    }\n    frame++;\n  }\n  return [Math.round(speed * frame), sorted]; // end time of sorting animation\n}\n\n// Creates an array of indices that are being compared/swapped during sorting\nfunction insertionSortAnimation(arr) {\n  const animations = [];\n  for (let i = 1; i < arr.length; i++) {\n    const next = arr[i];\n    let j = i - 1;\n    animations.push([i]); // next value being inserted\n    while (j >= 0 && next < arr[j]) {\n      arr[j + 1] = arr[j];\n      animations.push([j, j + 1]); // comparisons to insert at right spot\n      j--;\n    }\n    arr[j + 1] = next;\n  }\n  return [animations, arr];\n}\n","export function selectionSort(arr, speed, bars, colors) {\n  const [animations, sorted] = selectionSortAnimation(arr);\n  let frame = 0; // animation frame\n  for (let i = 0; i < animations.length; i++) {\n    switch (animations[i][0]) {\n      case \"next\":\n        // highlights ith position\n        setTimeout(() => {\n          bars[animations[i][1]].style.backgroundColor = colors.compare;\n        }, speed * frame);\n        break;\n      case \"search\":\n        // animation to search for ith smallest value in rest of array\n        setTimeout(() => {\n          bars[animations[i][1]].style.backgroundColor = colors.compare;\n        }, speed * frame);\n        frame++;\n        setTimeout(() => {\n          bars[animations[i][1]].style.backgroundColor = colors.unsorted;\n        }, speed * frame);\n        break;\n      case \"swap\":\n        // swaps ith position for ith smallest value\n        const [first, second] = animations[i].slice(1);\n        setTimeout(() => {\n          bars[first].style.backgroundColor = colors.swap;\n          bars[second].style.backgroundColor = colors.swap;\n        }, speed * frame);\n        frame++;\n        setTimeout(() => {\n          const tempHeight = bars[first].style.height;\n          bars[first].style.height = bars[second].style.height;\n          bars[second].style.height = tempHeight;\n        }, speed * frame);\n        frame++;\n        setTimeout(() => {\n          bars[first].style.backgroundColor = colors.unsorted;\n          bars[second].style.backgroundColor = colors.unsorted;\n        }, speed * frame);\n        break;\n      default:\n        console.log(\"error\");\n        break;\n    }\n    frame++;\n  }\n  return [Math.round(speed * frame), sorted]; // end time of sorting animation\n}\n\n// Creates an array of indices that are being compared/swapped during sorting\nfunction selectionSortAnimation(arr) {\n  const animations = [];\n  for (let i = 0; i < arr.length - 1; i++) {\n    animations.push([\"next\", i]); // next position to select min value\n    let min_idx = i;\n    for (let j = i + 1; j < arr.length; j++) {\n      animations.push([\"search\", j]); // searching for ith smallest value\n      if (arr[j] < arr[min_idx]) {\n        min_idx = j;\n      }\n    }\n\n    animations.push([\"swap\", i, min_idx]); // swap ith position with ith smallest value\n    const temp = arr[min_idx];\n    arr[min_idx] = arr[i];\n    arr[i] = temp;\n  }\n  return [animations, arr];\n}\n","export function mergeSort(arr, speed, bars, colors) {\n  const animations = [];\n  const sorted = mergeSortAnimation(arr, 0, arr.length - 1, animations);\n  let frame = 0; // animation frame\n  for (let i = 0; i < animations.length; i++) {\n    const [first, second] = animations[i].slice(1);\n    switch (animations[i][0]) {\n      // highlights the two bars being compared\n      case \"next\":\n        setTimeout(() => {\n          bars[first].style.backgroundColor = colors.compare;\n          bars[second].style.backgroundColor = colors.compare;\n        }, speed * frame);\n        frame++;\n        break;\n      case \"move\":\n        // moves the smallest of the two compared to kth index\n        if (first !== second) {\n          setTimeout(() => {\n            bars[first].style.backgroundColor = colors.swap;\n            bars[second].style.backgroundColor = colors.swap;\n          }, speed * frame);\n          frame++;\n          setTimeout(() => {\n            const tempHeight = bars[first].style.height;\n            bars[first].style.height = bars[second].style.height;\n            // this shifts all the bars in between one to the right\n            for (let j = second; j > first + 1; j--) {\n              bars[j].style.height = bars[j - 1].style.height;\n            }\n            bars[first + 1].style.height = tempHeight;\n          }, speed * frame);\n        }\n        break;\n      default:\n        console.log(\"error\");\n        break;\n    }\n    setTimeout(() => {\n      bars[first].style.backgroundColor = colors.unsorted;\n      bars[second].style.backgroundColor = colors.unsorted;\n    }, speed * frame);\n    frame++;\n  }\n  return [Math.round(speed * frame), sorted]; // end time of sorting animation\n}\n\n// Creates an array of indices that are being compared/swapped during sorting\n// This is standard merge sort but it also passes in the animations array\nfunction mergeSortAnimation(arr, l, r, animations) {\n  if (l < r) {\n    const m = Math.floor((l + r) / 2);\n\n    mergeSortAnimation(arr, l, m, animations);\n    mergeSortAnimation(arr, m + 1, r, animations);\n\n    merge(arr, l, m, r, animations);\n  }\n  return arr;\n}\n\n// helper merge function\nfunction merge(arr, l, m, r, animations) {\n  const L = arr.slice(l, m + 1);\n  const R = arr.slice(m + 1, r + 1);\n\n  let i = 0;\n  let j = 0;\n  let k = l;\n\n  while (i < L.length && j < R.length) {\n    animations.push([\"next\", l + i, m + 1 + j]); // two values being compared\n    if (L[i] < R[j]) {\n      arr[k] = L[i];\n      // checks to see whether elements are in order\n      // This is needed due to the shifting of heights in the animation but\n      // not in the actuala array indices\n      if (l + i >= k) {\n        animations.push([\"move\", k, l + i]); // move smaller value to current index\n      }\n      i++;\n    } else {\n      arr[k] = R[j];\n      if (m + 1 + j >= k) {\n        animations.push([\"move\", k, m + 1 + j]);\n      }\n      j++;\n    }\n    k++;\n  }\n\n  // add remaining elements\n  while (i < L.length) {\n    arr[k] = L[i];\n    i++;\n    k++;\n  }\n  while (j < R.length) {\n    arr[k] = R[j];\n    j++;\n    k++;\n  }\n}\n","export function heapSort(arr, speed, bars, colors) {\n  const animations = [];\n  const sorted = heapSortAnimation(arr, animations);\n  let frame = 0; // animation frame\n  for (let i = 0; i < animations.length; i++) {\n    const [first, second] = animations[i].slice(1);\n    switch (animations[i][0]) {\n      // highlights the two bars being compared\n      case \"compare\":\n        setTimeout(() => {\n          bars[first].style.backgroundColor = colors.compare;\n          bars[second].style.backgroundColor = colors.compare;\n        }, speed * frame);\n        frame++;\n        break;\n      // moves largest node to the root of subtree\n      case \"swap\":\n        setTimeout(() => {\n          bars[first].style.backgroundColor = colors.swap;\n          bars[second].style.backgroundColor = colors.swap;\n        }, speed * frame);\n        frame++;\n        setTimeout(() => {\n          const tempHeight = bars[first].style.height;\n          bars[first].style.height = bars[second].style.height;\n          bars[second].style.height = tempHeight;\n        }, speed * frame);\n        break;\n      // pops max element and percolates last element down\n      case \"pop\":\n        setTimeout(() => {\n          bars[first].style.backgroundColor = colors.swap;\n          bars[second].style.backgroundColor = colors.swap;\n        }, speed * frame);\n        frame++;\n        setTimeout(() => {\n          const tempHeight = bars[first].style.height;\n          bars[first].style.height = bars[second].style.height;\n          bars[second].style.height = tempHeight;\n        }, speed * frame);\n        break;\n      default:\n        console.log(\"error\");\n        break;\n    }\n    setTimeout(() => {\n      bars[first].style.backgroundColor = colors.unsorted;\n      bars[second].style.backgroundColor = colors.unsorted;\n    }, speed * frame);\n    frame++;\n  }\n  return [Math.round(speed * frame), sorted]; // end time of sorting animation\n}\n\n// Creates an array of indices that are being compared/swapped during sorting\n// This is standard heap sort but it also passes in the animations array\nfunction heapSortAnimation(arr, animations) {\n  for (let i = Math.floor(arr.length / 2) - 1; i >= 0; i--) {\n    heapify(arr, arr.length, i, animations);\n  }\n\n  for (let i = arr.length - 1; i > 0; i--) {\n    animations.push([\"pop\", 0, i]); // max element moving to the back of array\n    const temp = arr[0];\n    arr[0] = arr[i];\n    arr[i] = temp;\n    heapify(arr, i, 0, animations);\n  }\n  return arr;\n}\n\n// generates max heap\nfunction heapify(arr, n, i, animations) {\n  let largest = i;\n  const l = 2 * i + 1;\n  const r = 2 * i + 2;\n  if (l < n) {\n    animations.push([\"compare\", largest, l]); // shows comparison\n    if (arr[l] > arr[largest]) {\n      largest = l;\n    }\n  }\n  if (r < n) {\n    animations.push([\"compare\", largest, r]); // shows comparison\n    if (arr[r] > arr[largest]) {\n      largest = r;\n    }\n  }\n\n  if (largest !== i) {\n    animations.push([\"swap\", i, largest]); // reordering\n    const temp = arr[i];\n    arr[i] = arr[largest];\n    arr[largest] = temp;\n\n    heapify(arr, n, largest, animations);\n  }\n}\n","export const quickSort = (arr, speed, bars, colors) => {\n  const animations = [];\n  const sorted = quickSortAnimation(arr, 0, arr.length - 1, animations);\n  let frame = 0; // animation frame\n  for (let i = 0; i < animations.length; i++) {\n    const [first, second] = animations[i].slice(1);\n    switch (animations[i][0]) {\n      // highlights pivot\n      case \"pivot\":\n        setTimeout(() => {\n          bars[first].style.backgroundColor = \"#000\";\n        }, speed * frame);\n        break;\n      // highlights bar being compared to pivot\n      case \"compare\":\n        setTimeout(() => {\n          bars[first].style.backgroundColor = colors.compare;\n        }, speed * frame);\n        frame++;\n        setTimeout(() => {\n          bars[first].style.backgroundColor = colors.unsorted;\n        }, speed * frame);\n        break;\n      // moves bars into correct partition and swaps pivot with correct index\n      case \"swap\":\n        setTimeout(() => {\n          bars[first].style.backgroundColor = colors.swap;\n          bars[second].style.backgroundColor = colors.swap;\n        }, speed * frame);\n        frame++;\n        setTimeout(() => {\n          const tempHeight = bars[first].style.height;\n          bars[first].style.height = bars[second].style.height;\n          bars[second].style.height = tempHeight;\n        }, speed * frame);\n        frame++;\n        setTimeout(() => {\n          bars[first].style.backgroundColor = colors.unsorted;\n          bars[second].style.backgroundColor = colors.unsorted;\n        }, speed * frame);\n        break;\n      default:\n        console.log(\"error\");\n        break;\n    }\n    frame++;\n  }\n  return [Math.round(speed * frame), sorted]; // end time of sorting animation\n};\n\n// Creates an array of indices that are being compared/swapped during sorting\n// This is standard quick sort but it also passes in the animations array\nfunction quickSortAnimation(arr, low, high, animations) {\n  if (low < high) {\n    let p = partition(arr, low, high, animations);\n\n    quickSortAnimation(arr, low, p - 1, animations);\n    quickSortAnimation(arr, p + 1, high, animations);\n  }\n  return arr;\n}\n\n// partitions array around pivot\nfunction partition(arr, low, high, animations) {\n  const pivot = arr[high];\n  animations.push([\"pivot\", high]); // pivot index\n  let i = low; // low +_# of elements lower than pivot\n  for (let j = low; j < high; j++) {\n    animations.push([\"compare\", j]); // highlight element being compared to pivot\n    if (arr[j] < pivot) {\n      animations.push([\"swap\", i, j]); // move element into correct partition\n      const temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n    }\n  }\n  animations.push([\"swap\", i, high]); // place pivot element in correct index\n  arr[high] = arr[i];\n  arr[i] = pivot;\n  return i;\n}\n","import React from \"react\";\nimport Controls from \"./Controls.js\";\nimport { bubbleSort } from \"../algorithms/bubbleSort.js\";\nimport { insertionSort } from \"../algorithms/insertionSort.js\";\nimport { selectionSort } from \"../algorithms/selectionSort.js\";\nimport { mergeSort } from \"../algorithms/mergeSort.js\";\nimport { heapSort } from \"../algorithms/heapSort.js\";\nimport { quickSort } from \"../algorithms/quickSort.js\";\n\n// animation colors\nconst colors = {\n  unsorted: \"#2C75FF\", // blue\n  compare: \"#FEFF37\", // yellow\n  swap: \"#fd5e53\", // red\n  sorted: \"#79d70f\", // green\n};\n\nclass SortingVisualizer extends React.Component {\n  state = {\n    array: [],\n    inverse: 0, // percentage of 1/size, used to scale bar elements\n    algorithm: \"heap\",\n    sorted: false,\n    sorting: false,\n  };\n\n  barStyle = (value, idx) => {\n    return {\n      position: \"absolute\",\n      backgroundColor: colors.unsorted,\n      height: `${value / 11}%`, // gives a little space at top of container\n      width: `${this.state.inverse}%`,\n      borderRight: `${this.state.inverse}px solid #F2BD93`,\n      left: `${idx * this.state.inverse}%`,\n      bottom: \"0\",\n      float: \"left\",\n      marginBottom: \"0\",\n    };\n  };\n\n  componentDidMount() {\n    this.resetArray(100);\n  }\n\n  // generates a random array\n  resetArray = (size) => {\n    const array = [];\n    for (let i = 0; i < size; i++) {\n      array.push(randomInt(5, 1000));\n    }\n    const bars = document.getElementsByClassName(\"bar\");\n    if (this.state.sorted) {\n      for (let i = 0; i < bars.length; i++) {\n        bars[i].style.backgroundColor = colors.unsorted;\n      }\n    }\n    this.setState({ array, inverse: 100 * (1 / size), sorted: false });\n    // this.setState(test);\n  };\n\n  // does not update state of array, only css styling\n  sort = () => {\n    this.setState({ sorting: true });\n    let speed = undefined; //speed of animation, lower value indicates faster animation\n    const bars = document.getElementsByClassName(\"bar\");\n    const [finishTime, sortedArray] = this.runAlgorithm(\n      [...this.state.array],\n      speed,\n      bars,\n      colors\n    );\n    // paints the sorted array green once the animation of sorting is done\n    for (let i = finishTime; i < finishTime + this.state.array.length; i++) {\n      setTimeout(() => {\n        bars[i - finishTime].style.backgroundColor = colors.sorted;\n      }, finishTime + (1500 / this.state.array.length) * (i - finishTime));\n    }\n    setTimeout(() => {\n      this.setState({ array: sortedArray, sorting: false, sorted: true });\n    }, finishTime + (1500 / this.state.array.length) * this.state.array.length);\n  };\n\n  // chooses the algorithm to run based on algorithm this.state\n  // speed is determined by an arbitrary constant and the algorithm's asymptotic run time\n  runAlgorithm = (arr, speed, bars) => {\n    switch (this.state.algorithm) {\n      case \"bubble\":\n        speed = 9000 / arr.length ** 2;\n        return bubbleSort(arr, speed, bars, colors);\n      case \"selection\":\n        speed = 6500 / arr.length ** 2;\n        return selectionSort(arr, speed, bars, colors);\n      case \"insertion\":\n        speed = 12500 / arr.length ** 2;\n        return insertionSort(arr, speed, bars, colors);\n      case \"merge\":\n        speed = 5000 / (arr.length * Math.log2(arr.length));\n        return mergeSort(arr, speed, bars, colors);\n      case \"heap\":\n        speed = speed = 3000 / (arr.length * Math.log2(arr.length));\n        return heapSort(arr, speed, bars, colors);\n      case \"quick\":\n        speed = 4000 / (arr.length * Math.log2(arr.length));\n        return quickSort(arr, speed, bars, colors);\n      default:\n        console.log(\"error\");\n        break;\n    }\n  };\n\n  choose = (e) => {\n    if (this.state.sorted) {\n      this.resetArray(this.state.array.length);\n    }\n    this.setState({ algorithm: e.target.value });\n  };\n\n  render() {\n    return (\n      <React.Fragment>\n        <Controls\n          algorithm={this.state.algorithm}\n          array={this.state.array}\n          resetArray={this.resetArray}\n          sort={this.sort}\n          sorting={this.state.sorting}\n          choose={this.choose}\n        ></Controls>\n        <div className=\"container\">\n          {this.state.array.map((value, idx) => (\n            <div\n              className=\"bar\"\n              key={idx}\n              style={this.barStyle(value, idx)}\n            ></div>\n          ))}\n        </div>\n      </React.Fragment>\n    );\n  }\n}\n\nfunction randomInt(min, max) {\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n\nexport default SortingVisualizer;\n","import React from \"react\";\nimport SortingVisualizer from \"./components/SortingVisualizer.js\";\nimport \"./App.css\";\n\nclass App extends React.Component {\n  render() {\n    return (\n      <div className=\"App\">\n        <SortingVisualizer></SortingVisualizer>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}