{"version":3,"sources":["components/Controls.js","algorithms/bubbleSort.js","algorithms/insertionSort.js","algorithms/selectionSort.js","algorithms/mergeSort.js","algorithms/heapSort.js","algorithms/quickSort.js","components/SortingVisualizer.js","App.js","serviceWorker.js","index.js"],"names":["Controls","id","className","disabled","this","props","sorting","onClick","resetArray","bind","array","length","sorted","sort","value","algorithm","onChange","choose","htmlFor","type","name","min","max","step","e","target","React","Component","bubbleSort","arr","speed","bars","colors","animations","i","j","push","swap","temp","bubbleSortAnimation","frame","first","second","setTimeout","style","backgroundColor","compare","tempHeight","height","unsorted","Math","round","insertionSort","next","insertionSortAnimation","selectionSort","min_idx","selectionSortAnimation","slice","console","log","mergeSort","mergeSortAnimation","l","r","m","floor","L","R","k","merge","heapSort","heapify","heapSortAnimation","n","largest","quickSort","quickSortAnimation","low","high","p","pivot","partition","randomInt","random","SortingVisualizer","state","inverse","barStyle","idx","position","width","borderRight","left","bottom","float","marginBottom","size","document","getElementsByClassName","setState","runAlgorithm","undefined","finishTime","sortedArray","log2","Fragment","map","key","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.e194a974.chunk.js","sourcesContent":["import React from \"react\";\nimport PropTypes from \"prop-types\";\n\nclass Controls extends React.Component {\n  // onClick={() => this.newArray(this.props.array.length)}\n  render() {\n    return (\n      <header id=\"controlbar\">\n        <button\n          className=\"control\"\n          disabled={this.props.sorting}\n          onClick={this.props.resetArray.bind(this, this.props.array.length)}\n        >\n          Randomize\n        </button>\n        <button\n          className=\"control\"\n          disabled={this.props.sorting || this.props.sorted}\n          onClick={this.props.sort}\n        >\n          Sort\n        </button>\n        <select\n          value={this.props.algorithm}\n          id=\"algorithms\"\n          className=\"control\"\n          disabled={this.props.sorting}\n          onChange={this.props.choose}\n        >\n          <option value=\"bubble\">Bubble Sort</option>\n          <option value=\"selection\">Selection Sort</option>\n          <option value=\"insertion\">Insertion Sort</option>\n          <option value=\"merge\">Merge Sort</option>\n          <option value=\"heap\">Heap Sort</option>\n          <option value=\"quick\">Quick Sort</option>\n        </select>\n        <div id=\"slidecontainer\" className=\"control\">\n          <label htmlFor=\"size\">Size:</label>\n          <input\n            type=\"range\"\n            id=\"size\"\n            className=\"slider\"\n            name=\"size\"\n            min=\"5\"\n            max=\"300\"\n            step=\"1\"\n            value={this.props.array.length}\n            disabled={this.props.sorting}\n            onChange={(e) => {\n              this.props.resetArray(e.target.value);\n            }}\n          />\n        </div>\n      </header>\n    );\n  }\n}\n\nControls.propTypes = {\n  array: PropTypes.array.isRequired,\n  algorithm: PropTypes.string.isRequired,\n  sorting: PropTypes.bool.isRequired,\n  sorted: PropTypes.bool.isRequired,\n  resetArray: PropTypes.func.isRequired,\n  sort: PropTypes.func.isRequired,\n  choose: PropTypes.func.isRequired,\n};\n\nexport default Controls;\n","export function bubbleSort(arr, speed, bars, colors) {\n  const [animations, sorted] = bubbleSortAnimation(arr);\n  let frame = 0; // animation frame\n  for (let i = 0; i < animations.length; i++) {\n    const [first, second] = animations[i];\n    // highlight two bars being compared\n    setTimeout(() => {\n      bars[first].style.backgroundColor = colors.compare;\n      bars[second].style.backgroundColor = colors.compare;\n    }, speed * frame);\n    frame++;\n    i++;\n    // indicate if they need to be swapped and swap them\n    setTimeout(() => {\n      if (animations[i]) {\n        bars[first].style.backgroundColor = colors.swap;\n        bars[second].style.backgroundColor = colors.swap;\n        const tempHeight = bars[first].style.height;\n        bars[first].style.height = bars[second].style.height;\n        bars[second].style.height = tempHeight;\n      }\n    }, speed * frame);\n    frame++;\n    // return back to normal color\n    setTimeout(() => {\n      bars[first].style.backgroundColor = colors.unsorted;\n      bars[second].style.backgroundColor = colors.unsorted;\n    }, speed * frame);\n    frame++;\n  }\n  return [Math.round(speed * frame), sorted]; // end time of sorting animation\n}\n\n// Creates an array of indices that are being compared/swapped during sorting\nfunction bubbleSortAnimation(arr) {\n  const animations = [];\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr.length - 1 - i; j++) {\n      animations.push([j, j + 1]); // two adjacent values being compared\n      let swap = arr[j] > arr[j + 1];\n      animations.push(swap); // whether the two values are out of order\n      if (swap) {\n        const temp = arr[j];\n        arr[j] = arr[j + 1];\n        arr[j + 1] = temp;\n      }\n    }\n  }\n  return [animations, arr];\n}\n","export function insertionSort(arr, speed, bars, colors) {\n  const [animations, sorted] = insertionSortAnimation(arr);\n  let frame = 0; // animation frame\n  for (let i = 0; i < animations.length; i++) {\n    // highlights next bar to be inserted\n    if (animations[i].length === 1) {\n      setTimeout(() => {\n        bars[animations[i]].style.backgroundColor = colors.compare;\n      }, speed * frame);\n      // returns bar to normal color if it is already in the right spot\n      if (i + 1 >= animations.length || animations[i + 1].length === 1) {\n        frame++;\n        setTimeout(() => {\n          bars[animations[i]].style.backgroundColor = colors.unsorted;\n        }, speed * frame);\n      }\n    } else {\n      const [first, second] = animations[i];\n      // highlights comparisons for insert\n      setTimeout(() => {\n        bars[first].style.backgroundColor = colors.swap;\n        bars[second].style.backgroundColor = colors.swap;\n      }, speed * frame);\n      frame++;\n      // switches values\n      setTimeout(() => {\n        const tempHeight = bars[first].style.height;\n        bars[first].style.height = bars[second].style.height;\n        bars[second].style.height = tempHeight;\n      }, speed * frame);\n      frame++;\n      // returns bars to normal colors\n      setTimeout(() => {\n        bars[first].style.backgroundColor = colors.unsorted;\n        bars[second].style.backgroundColor = colors.unsorted;\n      }, speed * frame);\n    }\n    frame++;\n  }\n  return [Math.round(speed * frame), sorted]; // end time of sorting animation\n}\n\n// Creates an array of indices that are being compared/swapped during sorting\nfunction insertionSortAnimation(arr) {\n  const animations = [];\n  for (let i = 1; i < arr.length; i++) {\n    const next = arr[i];\n    let j = i - 1;\n    animations.push([i]); // next value being inserted\n    while (j >= 0 && next < arr[j]) {\n      arr[j + 1] = arr[j];\n      animations.push([j, j + 1]); // comparisons to insert at right spot\n      j--;\n    }\n    arr[j + 1] = next;\n  }\n  return [animations, arr];\n}\n","export function selectionSort(arr, speed, bars, colors) {\n  const [animations, sorted] = selectionSortAnimation(arr);\n  let frame = 0; // animation frame\n  for (let i = 0; i < animations.length; i++) {\n    switch (animations[i][0]) {\n      case \"next\":\n        // highlights ith position\n        setTimeout(() => {\n          bars[animations[i][1]].style.backgroundColor = colors.compare;\n        }, speed * frame);\n        break;\n      case \"search\":\n        // animation to search for ith smallest value in rest of array\n        setTimeout(() => {\n          bars[animations[i][1]].style.backgroundColor = colors.compare;\n        }, speed * frame);\n        frame++;\n        setTimeout(() => {\n          bars[animations[i][1]].style.backgroundColor = colors.unsorted;\n        }, speed * frame);\n        break;\n      case \"swap\":\n        // swaps ith position for ith smallest value\n        const [first, second] = animations[i].slice(1);\n        setTimeout(() => {\n          bars[first].style.backgroundColor = colors.swap;\n          bars[second].style.backgroundColor = colors.swap;\n        }, speed * frame);\n        frame++;\n        setTimeout(() => {\n          const tempHeight = bars[first].style.height;\n          bars[first].style.height = bars[second].style.height;\n          bars[second].style.height = tempHeight;\n        }, speed * frame);\n        frame++;\n        setTimeout(() => {\n          bars[first].style.backgroundColor = colors.unsorted;\n          bars[second].style.backgroundColor = colors.unsorted;\n        }, speed * frame);\n        break;\n      default:\n        console.log(\"error\");\n        break;\n    }\n    frame++;\n  }\n  return [Math.round(speed * frame), sorted]; // end time of sorting animation\n}\n\n// Creates an array of indices that are being compared/swapped during sorting\nfunction selectionSortAnimation(arr) {\n  const animations = [];\n  for (let i = 0; i < arr.length - 1; i++) {\n    animations.push([\"next\", i]); // next position to select min value\n    let min_idx = i;\n    for (let j = i + 1; j < arr.length; j++) {\n      animations.push([\"search\", j]); // searching for ith smallest value\n      if (arr[j] < arr[min_idx]) {\n        min_idx = j;\n      }\n    }\n\n    animations.push([\"swap\", i, min_idx]); // swap ith position with ith smallest value\n    const temp = arr[min_idx];\n    arr[min_idx] = arr[i];\n    arr[i] = temp;\n  }\n  return [animations, arr];\n}\n","export function mergeSort(arr, speed, bars, colors) {\n  const animations = [];\n  const sorted = mergeSortAnimation(arr, 0, arr.length - 1, animations);\n  let frame = 0; // animation frame\n  for (let i = 0; i < animations.length; i++) {\n    const [first, second] = animations[i].slice(1);\n    switch (animations[i][0]) {\n      // highlights the two bars being compared\n      case \"next\":\n        setTimeout(() => {\n          bars[first].style.backgroundColor = colors.compare;\n          bars[second].style.backgroundColor = colors.compare;\n        }, speed * frame);\n        frame++;\n        break;\n      case \"move\":\n        // moves the smallest of the two compared to kth index\n        if (first !== second) {\n          setTimeout(() => {\n            bars[first].style.backgroundColor = colors.swap;\n            bars[second].style.backgroundColor = colors.swap;\n          }, speed * frame);\n          frame++;\n          setTimeout(() => {\n            const tempHeight = bars[first].style.height;\n            bars[first].style.height = bars[second].style.height;\n            // this shifts all the bars in between one to the right\n            for (let j = second; j > first + 1; j--) {\n              bars[j].style.height = bars[j - 1].style.height;\n            }\n            bars[first + 1].style.height = tempHeight;\n          }, speed * frame);\n        }\n        break;\n      default:\n        console.log(\"error\");\n        break;\n    }\n    setTimeout(() => {\n      bars[first].style.backgroundColor = colors.unsorted;\n      bars[second].style.backgroundColor = colors.unsorted;\n    }, speed * frame);\n    frame++;\n  }\n  return [Math.round(speed * frame), sorted]; // end time of sorting animation\n}\n\n// Creates an array of indices that are being compared/swapped during sorting\n// This is standard merge sort but it also passes in the animations array\nfunction mergeSortAnimation(arr, l, r, animations) {\n  if (l < r) {\n    const m = Math.floor((l + r) / 2);\n\n    mergeSortAnimation(arr, l, m, animations);\n    mergeSortAnimation(arr, m + 1, r, animations);\n\n    merge(arr, l, m, r, animations);\n  }\n  return arr;\n}\n\n// helper merge function\nfunction merge(arr, l, m, r, animations) {\n  const L = arr.slice(l, m + 1);\n  const R = arr.slice(m + 1, r + 1);\n\n  let i = 0;\n  let j = 0;\n  let k = l;\n\n  while (i < L.length && j < R.length) {\n    animations.push([\"next\", l + i, m + 1 + j]); // two values being compared\n    if (L[i] < R[j]) {\n      arr[k] = L[i];\n      // checks to see whether elements are in order\n      // This is needed due to the shifting of heights in the animation but\n      // not in the actuala array indices\n      if (l + i >= k) {\n        animations.push([\"move\", k, l + i]); // move smaller value to current index\n      }\n      i++;\n    } else {\n      arr[k] = R[j];\n      if (m + 1 + j >= k) {\n        animations.push([\"move\", k, m + 1 + j]);\n      }\n      j++;\n    }\n    k++;\n  }\n\n  // add remaining elements\n  while (i < L.length) {\n    arr[k] = L[i];\n    i++;\n    k++;\n  }\n  while (j < R.length) {\n    arr[k] = R[j];\n    j++;\n    k++;\n  }\n}\n","export function heapSort(arr, speed, bars, colors) {\n  const animations = [];\n  const sorted = heapSortAnimation(arr, animations);\n  let frame = 0; // animation frame\n  for (let i = 0; i < animations.length; i++) {\n    const [first, second] = animations[i].slice(1);\n    switch (animations[i][0]) {\n      // highlights the two bars being compared\n      case \"compare\":\n        setTimeout(() => {\n          bars[first].style.backgroundColor = colors.compare;\n          bars[second].style.backgroundColor = colors.compare;\n        }, speed * frame);\n        frame++;\n        break;\n      // moves largest node to the root of subtree\n      case \"swap\":\n        setTimeout(() => {\n          bars[first].style.backgroundColor = colors.swap;\n          bars[second].style.backgroundColor = colors.swap;\n        }, speed * frame);\n        frame++;\n        setTimeout(() => {\n          const tempHeight = bars[first].style.height;\n          bars[first].style.height = bars[second].style.height;\n          bars[second].style.height = tempHeight;\n        }, speed * frame);\n        break;\n      // pops max element and percolates last element down\n      case \"pop\":\n        setTimeout(() => {\n          bars[first].style.backgroundColor = colors.swap;\n          bars[second].style.backgroundColor = colors.swap;\n        }, speed * frame);\n        frame++;\n        setTimeout(() => {\n          const tempHeight = bars[first].style.height;\n          bars[first].style.height = bars[second].style.height;\n          bars[second].style.height = tempHeight;\n        }, speed * frame);\n        break;\n      default:\n        console.log(\"error\");\n        break;\n    }\n    setTimeout(() => {\n      bars[first].style.backgroundColor = colors.unsorted;\n      bars[second].style.backgroundColor = colors.unsorted;\n    }, speed * frame);\n    frame++;\n  }\n  return [Math.round(speed * frame), sorted]; // end time of sorting animation\n}\n\n// Creates an array of indices that are being compared/swapped during sorting\n// This is standard heap sort but it also passes in the animations array\nfunction heapSortAnimation(arr, animations) {\n  for (let i = Math.floor(arr.length / 2) - 1; i >= 0; i--) {\n    heapify(arr, arr.length, i, animations);\n  }\n\n  for (let i = arr.length - 1; i > 0; i--) {\n    animations.push([\"pop\", 0, i]); // max element moving to the back of array\n    const temp = arr[0];\n    arr[0] = arr[i];\n    arr[i] = temp;\n    heapify(arr, i, 0, animations);\n  }\n  return arr;\n}\n\n// generates max heap\nfunction heapify(arr, n, i, animations) {\n  let largest = i;\n  const l = 2 * i + 1;\n  const r = 2 * i + 2;\n  if (l < n) {\n    animations.push([\"compare\", largest, l]); // shows comparison\n    if (arr[l] > arr[largest]) {\n      largest = l;\n    }\n  }\n  if (r < n) {\n    animations.push([\"compare\", largest, r]); // shows comparison\n    if (arr[r] > arr[largest]) {\n      largest = r;\n    }\n  }\n\n  if (largest !== i) {\n    animations.push([\"swap\", i, largest]); // reordering\n    const temp = arr[i];\n    arr[i] = arr[largest];\n    arr[largest] = temp;\n\n    heapify(arr, n, largest, animations);\n  }\n}\n","export const quickSort = (arr, speed, bars, colors) => {\n  const animations = [];\n  const sorted = quickSortAnimation(arr, 0, arr.length - 1, animations);\n  let frame = 0; // animation frame\n  for (let i = 0; i < animations.length; i++) {\n    const [first, second] = animations[i].slice(1);\n    switch (animations[i][0]) {\n      // highlights pivot\n      case \"pivot\":\n        setTimeout(() => {\n          bars[first].style.backgroundColor = \"#000\";\n        }, speed * frame);\n        break;\n      // highlights bar being compared to pivot\n      case \"compare\":\n        setTimeout(() => {\n          bars[first].style.backgroundColor = colors.compare;\n        }, speed * frame);\n        frame++;\n        setTimeout(() => {\n          bars[first].style.backgroundColor = colors.unsorted;\n        }, speed * frame);\n        break;\n      // moves bars into correct partition and swaps pivot with correct index\n      case \"swap\":\n        setTimeout(() => {\n          bars[first].style.backgroundColor = colors.swap;\n          bars[second].style.backgroundColor = colors.swap;\n        }, speed * frame);\n        frame++;\n        setTimeout(() => {\n          const tempHeight = bars[first].style.height;\n          bars[first].style.height = bars[second].style.height;\n          bars[second].style.height = tempHeight;\n        }, speed * frame);\n        frame++;\n        setTimeout(() => {\n          bars[first].style.backgroundColor = colors.unsorted;\n          bars[second].style.backgroundColor = colors.unsorted;\n        }, speed * frame);\n        break;\n      default:\n        console.log(\"error\");\n        break;\n    }\n    frame++;\n  }\n  return [Math.round(speed * frame), sorted]; // end time of sorting animation\n};\n\n// Creates an array of indices that are being compared/swapped during sorting\n// This is standard quick sort but it also passes in the animations array\nfunction quickSortAnimation(arr, low, high, animations) {\n  if (low < high) {\n    let p = partition(arr, low, high, animations);\n\n    quickSortAnimation(arr, low, p - 1, animations);\n    quickSortAnimation(arr, p + 1, high, animations);\n  }\n  return arr;\n}\n\n// partitions array around pivot\nfunction partition(arr, low, high, animations) {\n  const pivot = arr[high];\n  animations.push([\"pivot\", high]); // pivot index\n  let i = low; // low +_# of elements lower than pivot\n  for (let j = low; j < high; j++) {\n    animations.push([\"compare\", j]); // highlight element being compared to pivot\n    if (arr[j] < pivot) {\n      animations.push([\"swap\", i, j]); // move element into correct partition\n      const temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n      i++;\n    }\n  }\n  animations.push([\"swap\", i, high]); // place pivot element in correct index\n  arr[high] = arr[i];\n  arr[i] = pivot;\n  return i;\n}\n","import React from \"react\";\nimport Controls from \"./Controls.js\";\nimport { bubbleSort } from \"../algorithms/bubbleSort.js\";\nimport { insertionSort } from \"../algorithms/insertionSort.js\";\nimport { selectionSort } from \"../algorithms/selectionSort.js\";\nimport { mergeSort } from \"../algorithms/mergeSort.js\";\nimport { heapSort } from \"../algorithms/heapSort.js\";\nimport { quickSort } from \"../algorithms/quickSort.js\";\n\n// animation colors\nconst colors = {\n  unsorted: \"#2C75FF\", // blue\n  compare: \"#FEFF37\", // yellow\n  swap: \"#fd5e53\", // red\n  sorted: \"#79d70f\", // green\n};\n\nclass SortingVisualizer extends React.Component {\n  state = {\n    array: [],\n    inverse: 0, // percentage of 1/size, used to scale bar elements\n    algorithm: \"quick\",\n    sorted: false,\n    sorting: false,\n  };\n\n  barStyle = (value, idx) => {\n    return {\n      position: \"absolute\",\n      backgroundColor: colors.unsorted,\n      height: `${value / 11}%`, // gives a little space at top of container\n      width: `${this.state.inverse}%`,\n      borderRight: `${this.state.inverse}px solid #F2BD93`,\n      left: `${idx * this.state.inverse}%`,\n      bottom: \"0\",\n      float: \"left\",\n      marginBottom: \"0\",\n    };\n  };\n\n  componentDidMount() {\n    this.resetArray(100);\n  }\n\n  // generates a random array\n  resetArray = (size) => {\n    const array = [];\n    for (let i = 0; i < size; i++) {\n      array.push(randomInt(5, 1000));\n    }\n    const bars = document.getElementsByClassName(\"bar\");\n    if (this.state.sorted) {\n      for (let i = 0; i < bars.length; i++) {\n        bars[i].style.backgroundColor = colors.unsorted;\n      }\n    }\n    this.setState({ array, inverse: 100 * (1 / size), sorted: false });\n    // this.setState(test);\n  };\n\n  // does not update state of array, only css styling\n  sort = () => {\n    this.setState({ sorting: true });\n    let speed = undefined; //speed of animation, lower value indicates faster animation\n    const bars = document.getElementsByClassName(\"bar\");\n    const [finishTime, sortedArray] = this.runAlgorithm(\n      [...this.state.array],\n      speed,\n      bars,\n      colors\n    );\n    // paints the sorted array green once the animation of sorting is done\n    for (let i = finishTime; i < finishTime + this.state.array.length; i++) {\n      setTimeout(() => {\n        bars[i - finishTime].style.backgroundColor = colors.sorted;\n      }, finishTime + (1500 / this.state.array.length) * (i - finishTime));\n    }\n    setTimeout(() => {\n      this.setState({ array: sortedArray, sorting: false, sorted: true });\n    }, finishTime + (1500 / this.state.array.length) * this.state.array.length);\n  };\n\n  // chooses the algorithm to run based on algorithm this.state\n  // speed is determined by an arbitrary constant and the algorithm's asymptotic run time\n  runAlgorithm = (arr, speed, bars) => {\n    switch (this.state.algorithm) {\n      case \"bubble\":\n        speed = 9000 / arr.length ** 2;\n        return bubbleSort(arr, speed, bars, colors);\n      case \"selection\":\n        speed = 6500 / arr.length ** 2;\n        return selectionSort(arr, speed, bars, colors);\n      case \"insertion\":\n        speed = 12500 / arr.length ** 2;\n        return insertionSort(arr, speed, bars, colors);\n      case \"merge\":\n        speed = 5000 / (arr.length * Math.log2(arr.length));\n        return mergeSort(arr, speed, bars, colors);\n      case \"heap\":\n        speed = speed = 3000 / (arr.length * Math.log2(arr.length));\n        return heapSort(arr, speed, bars, colors);\n      case \"quick\":\n        speed = 4000 / (arr.length * Math.log2(arr.length));\n        return quickSort(arr, speed, bars, colors);\n      default:\n        console.log(\"error\");\n        break;\n    }\n  };\n\n  choose = (e) => {\n    if (this.state.sorted) {\n      this.resetArray(this.state.array.length);\n    }\n    this.setState({ algorithm: e.target.value });\n  };\n\n  render() {\n    return (\n      <React.Fragment>\n        <Controls\n          algorithm={this.state.algorithm}\n          array={this.state.array}\n          sorting={this.state.sorting}\n          sorted={this.state.sorted}\n          resetArray={this.resetArray}\n          sort={this.sort}\n          choose={this.choose}\n        ></Controls>\n        <div className=\"container\">\n          {this.state.array.map((value, idx) => (\n            <div\n              className=\"bar\"\n              key={idx}\n              style={this.barStyle(value, idx)}\n            ></div>\n          ))}\n        </div>\n      </React.Fragment>\n    );\n  }\n}\n\nfunction randomInt(min, max) {\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n\nexport default SortingVisualizer;\n","import React from \"react\";\nimport SortingVisualizer from \"./components/SortingVisualizer.js\";\nimport \"./App.css\";\n\nclass App extends React.Component {\n  render() {\n    return (\n      <div className=\"App\">\n        <SortingVisualizer></SortingVisualizer>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}